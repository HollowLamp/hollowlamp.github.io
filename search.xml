<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CSCI0300-lab3 main:what can i say?,&quot;gets()&quot; out!</title>
      <link href="/posts/b18b4529.html"/>
      <url>/posts/b18b4529.html</url>
      
        <content type="html"><![CDATA[<p>CSCI0300是布朗大学开设的一门计算机系统导论课程，讲授计算机系统基础，此课程视频不公开，但每节课都有notes。本年度的实验与项目资料都公开，但过期后可能会删除，本人使用24spring的实验环境，做的是23spring的实验与项目。</p><hr><p>本篇记录lab3的完成过程，我水平有限，有什么出错的地方欢迎指正。</p><p>课程进行到lab3已经完成了C语言和x86汇编的讲解。</p><h2 id="第一部分：Defusing-Traps"><a href="#第一部分：Defusing-Traps" class="headerlink" title="第一部分：Defusing Traps"></a>第一部分：<strong>Defusing Traps</strong></h2><p>对于2个给定的可执行文件trap1和trap2，需要我们根据x86代码给出合适的输出，让trap函数返回值是1</p><p>对于可执行文件，可以使用objdump获得其汇编代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">objdump -d &lt;executable name&gt;</span></span><br></pre></td></tr></table></figure><p>可以将汇编代码重定向到文件中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">objdump -d &lt;executable name&gt; &gt; saved_output.txt</span></span><br></pre></td></tr></table></figure><h3 id="trap1"><a href="#trap1" class="headerlink" title="trap1"></a>trap1</h3><p>trap1文件的汇编代码中trap1的函数部分如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">00000000000008f5 &lt;trap1&gt;:</span><br><span class="line"> 8f5:55                   push   %rbp</span><br><span class="line"> 8f6:48 89 e5             mov    %rsp,%rbp</span><br><span class="line"> 8f9:89 7d ec             mov    %edi,-0x14(%rbp)</span><br><span class="line"> 8fc:c7 45 fc 1e 05 00 00 movl   $0x51e,-0x4(%rbp)</span><br><span class="line"> 903:8b 45 ec             mov    -0x14(%rbp),%eax</span><br><span class="line"> 906:3b 45 fc             cmp    -0x4(%rbp),%eax</span><br><span class="line"> 909:0f 9f c0             setg   %al</span><br><span class="line"> 90c:0f b6 c0             movzbl %al,%eax</span><br><span class="line"> 90f:5d                   pop    %rbp</span><br><span class="line"> 910:c3                   retq   </span><br><span class="line"> 911:66 2e 0f 1f 84 00 00 nopw   %cs:0x0(%rax,%rax,1)</span><br><span class="line"> 918:00 00 00 </span><br><span class="line"> 91b:0f 1f 44 00 00       nopl   0x0(%rax,%rax,1)</span><br></pre></td></tr></table></figure><p>详细的x86教程可以参考课程相应的notes</p><p>此处我们输入的参数应当大于0x51e，即1310</p><p><img src="https://bu.dusays.com/2024/03/17/65f6d83b4a996.png" alt="image-20240317194702768"></p><p>解除陷阱成功</p><h3 id="trap2"><a href="#trap2" class="headerlink" title="trap2"></a>trap2</h3><p>与trap1类似</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">0000000000000965 &lt;trap2&gt;:</span><br><span class="line"> 965:55                   push   %rbp</span><br><span class="line"> 966:48 89 e5             mov    %rsp,%rbp</span><br><span class="line"> 969:89 7d ec             mov    %edi,-0x14(%rbp)</span><br><span class="line"> 96c:89 75 e8             mov    %esi,-0x18(%rbp)</span><br><span class="line"> 96f:c7 45 f8 00 00 00 00 movl   $0x0,-0x8(%rbp)</span><br><span class="line"> 976:c7 45 fc 00 00 00 00 movl   $0x0,-0x4(%rbp)</span><br><span class="line"> 97d:eb 08                jmp    987 &lt;trap2+0x22&gt;</span><br><span class="line"> 97f:83 45 f8 64          addl   $0x64,-0x8(%rbp)</span><br><span class="line"> 983:83 45 fc 01          addl   $0x1,-0x4(%rbp)</span><br><span class="line"> 987:83 7d fc 09          cmpl   $0x9,-0x4(%rbp)</span><br><span class="line"> 98b:7e f2                jle    97f &lt;trap2+0x1a&gt;</span><br><span class="line"> 98d:8b 55 ec             mov    -0x14(%rbp),%edx</span><br><span class="line"> 990:8b 45 e8             mov    -0x18(%rbp),%eax</span><br><span class="line"> 993:01 c2                add    %eax,%edx</span><br><span class="line"> 995:8b 45 f8             mov    -0x8(%rbp),%eax</span><br><span class="line"> 998:01 c0                add    %eax,%eax</span><br><span class="line"> 99a:39 c2                cmp    %eax,%edx</span><br><span class="line"> 99c:0f 94 c0             sete   %al</span><br><span class="line"> 99f:0f b6 c0             movzbl %al,%eax</span><br><span class="line"> 9a2:5d                   pop    %rbp</span><br><span class="line"> 9a3:c3                   ret    </span><br><span class="line"> 9a4:66 2e 0f 1f 84 00 00 cs nopw 0x0(%rax,%rax,1)</span><br><span class="line"> 9ab:00 00 00 </span><br><span class="line"> 9ae:66 90                xchg   %ax,%ax</span><br></pre></td></tr></table></figure><p>如果直接看汇编不好看出来，可以gdb调试程序</p><p><code>layout asm</code>可以显示汇编代码</p><p><code>p $reg</code>可以打印相应寄存器的内容</p><p><code>x address</code>可以打印相应地址的内容</p><p>gdb中单步运行时注意打印寄存器的值，就可以发现最终此处需要两个参数之和为2000，才能让<code>%al</code>为1</p><p><img src="https://bu.dusays.com/2024/03/17/65f6d9c53e263.png" alt="image-20240317195339061"></p><p>解除成功</p><h2 id="第二部分：缓冲溢出"><a href="#第二部分：缓冲溢出" class="headerlink" title="第二部分：缓冲溢出"></a>第二部分：缓冲溢出</h2><p>本部分的核心是利用<code>gets()</code>函数进行缓冲区溢出攻击</p><p><img src="https://bu.dusays.com/2024/03/17/65f6daa222582.png" alt="image-20240317195719761"></p><p>以如下程序为例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123; </span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">8</span>];</span><br><span class="line">    gets(buffer); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该程序从栈分配的缓冲区中读取字符串，若用户输入超过7个字符就会出现问题。</p><p><em>为什么是七个？因为gets给读入的字符最后加上\0</em></p><p>本实验通过专门设定的编译命令让栈稳定且容易被攻击</p><p>我们需要攻击的程序如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFSIZE 32</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// unused...?</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">hack</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;you&#x27;ve been hacked!\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// stack allocate some variables</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> fav_number = <span class="number">13</span>; <span class="comment">// your favorite number is a constant so it can&#x27;t change</span></span><br><span class="line">    <span class="type">char</span> buf[BUFSIZE];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// print favorite number</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;My favorite number is %d and it will always be %d and nothing can change that\n&quot;</span>, fav_number, fav_number);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get a string from stdin</span></span><br><span class="line">    gets(buf);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// print favorite number again bc its a great number and you want the world to know</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;My favorite number is %d and it will always be %d and nothing can change that\n&quot;</span>, fav_number, fav_number);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line"></span><br><span class="line">    foo();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Returned to main safe and sound\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>数字fav_number可自行设定，反正它不是不可change的。XD</p><p>正常情况如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./buffer</span></span><br><span class="line">My favorite number is 13 and it will always be 13 and nothing can change that</span><br><span class="line">1234567 # user input</span><br><span class="line">My favorite number is 13 and it will always be 13 and nothing can change that</span><br><span class="line">Returned to main safe and sound</span><br></pre></td></tr></table></figure><h3 id="溢出1"><a href="#溢出1" class="headerlink" title="溢出1"></a>溢出1</h3><p>通过直接输入，让缓冲区溢出，以修改第二次输出的数字</p><p>为此我们需要知晓缓冲区和fav_number的位置，在gdb中调试可见</p><p><img src="https://bu.dusays.com/2024/03/17/65f6dcd4e0598.png" alt="image-20240317200643234"></p><p>缓冲区在数字之下，且相差0x2c&#x3D;44个字节，意味着我们只需要输入44个字符，即可覆盖入fav_number(<em>思考：相差的是44个，为什么只需要输入44个字节</em>)</p><p>和我一样不太熟悉数字在内存中存放方式的，可能会好奇，int是4个字节，一个字符只有一个字节，1个字节覆盖的是int的高位还是低位？通过试验可以得出结论。</p><p>将数字修改为<code>436900</code>，对应十六进制为<code>0x6aaa4</code></p><p>输入44个1</p><p><img src="https://bu.dusays.com/2024/03/17/65f6e09791c2d.png" alt="image-20240317202245555"></p><p><code>436736</code>对应<code>0x6aa00</code>，这里解释了为什么只需要44个字符，因为第45个是gets()的\0，0x00覆盖了低位，而不是1对应的值覆盖了低位</p><h3 id="溢出2"><a href="#溢出2" class="headerlink" title="溢出2"></a>溢出2</h3><p>为了避免总是需要手动输入字符，实验提供了辅助函数exploit，可以在其中直接设定输入的十六进制数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> exploit[] = <span class="string">&quot;\x00\x00\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">                       <span class="string">&quot;\x00\x00\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">                       <span class="string">&quot;\x00\x00\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">                       <span class="string">&quot;\x00\x00\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">                       <span class="string">&quot;\x00\x00\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">                       <span class="string">&quot;\x00\x00\x00\x00\x83&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> \* Write the exploit bytes to stdout</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// strings are null terminated so we write the sizeof the exploit string minus 1 </span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// to only write out the bytes specified </span></span><br><span class="line"></span><br><span class="line">  write(STDOUT_FILENO,exploit,<span class="keyword">sizeof</span>(exploit) <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// free(e);</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们需要修改此程序使之输出131。131对应0x83，直接改即可。</p><p><em>这里只写到了第45个，写文章的时候思考了一下字符填入高低位的问题才发现，如果数字很大的话，只写到45个字节只能覆盖数字的低2个字节，大于2个字节的部分是无法覆盖的，如果需要保证完成题目要求，应当写到第47个字节，第48个由gets填补的\0来，修改后效果如下</em></p><p><img src="https://bu.dusays.com/2024/03/17/65f6e5381999e.png" alt="image-20240317204229781"></p><h3 id="溢出3"><a href="#溢出3" class="headerlink" title="溢出3"></a>溢出3</h3><p>注意到提供的代码中包含此部分</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// unused...?</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">hack</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;you&#x27;ve been hacked!\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们需要提供合适的输入，来让foo执行之后不返回到main，而是执行此函数。</p><p>这里需要x86的调用堆栈知识，可以在此<a href="https://cs.brown.edu/courses/csci0300/2023/assign/labs/lab3.html">链接</a>的对应部分查看。</p><p>原本的调用结束返回流程如下</p><p><img src="https://bu.dusays.com/2024/03/17/65f6eedc18fc6.png" alt="image-20240317210400303"></p><p>我们只需要修改返回地址，让rip指向hack即可，返回地址的位置我们可以通过看实验文件提供的反汇编代码得到，也可以在gdb中调试得到，汇编指令表明在foo中分配了48个字节，buf位于最底部，rbp与地址都是32位，则buf距离返回地址有56个字节，之后再找出hack函数对应的指令地址即可知道需要rip定位到哪里。</p><p>最终我们写入的数据如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> exploit[] = <span class="string">&quot;\x00\x00\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">                       <span class="string">&quot;\x00\x00\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">                       <span class="string">&quot;\x00\x00\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">                       <span class="string">&quot;\x00\x00\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">                       <span class="string">&quot;\x00\x00\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">                       <span class="string">&quot;\x00\x00\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">                       <span class="string">&quot;\x00\x00\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">                       <span class="string">&quot;\x56\x11\x40&quot;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2024/03/17/65f6ec46bb0b4.png" alt="image-20240317211236551"></p>]]></content>
      
      
      <categories>
          
          <category> 学习小结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CS课程 </tag>
            
            <tag> 学习记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS70学习记录-递归与数学归纳</title>
      <link href="/posts/12e4fd6e.html"/>
      <url>/posts/12e4fd6e.html</url>
      
        <content type="html"><![CDATA[<p>CS70 note3 主要讲的是数学归纳法，其中也谈到了数学归纳与递归函数的关系。以下是note 3中的两个问题，感觉还挺有意思。笔者此时还没学过正经的算法分析课，理解不到位的地方欢迎指正。</p><h3 id="Postage-Stamp-Problem"><a href="#Postage-Stamp-Problem" class="headerlink" title="Postage Stamp Problem"></a>Postage Stamp Problem</h3><p>原题</p><p>Use the proof of Theorem 3.6 to design an algorithm that, given any amount of postage of at least 12c, outputs the numbers of 4c and 5c stamps that make up this postage. What’s the largest number of 5c stamps your algorithm will ever use?</p><p><img src="https://bu.dusays.com/2024/03/04/65e4a3f10d395.png"></p><p>大意就是根据这个归纳法证明的思路，设计一个算法，输入一个n，输出对应x与y</p><p>这里归纳法的思路就是，给出4个base case，之后假设在一个范围内，对于每一个n都成立，这个范围称为假设成立范围，然后将范围扩大一个数，我们需要证明对于多加的k+1也成立。我们的假设成立范围是[12, k]，而要证明的k+1在[16, 无穷大]这个范围内。而k+1-4&#x3D;k-3处在[12, k]范围内，说明k+1-4可以被表示为4x+5y的形式，那么k+1就必然可以被表示为4(x + 1)+5y的形式，说明对于k+1也成立，证明完成。</p><p>显然这题作为一个程序设计题有很多写法，效率也各不相同，按题目的意思来做不一定是最高效的写法。</p><p>按这个证明的思路写递归还是很好写的，一步步翻译就好了</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">comb</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">12</span>:</span><br><span class="line">        <span class="keyword">return</span> [<span class="number">3</span>, <span class="number">0</span>]</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">13</span>:</span><br><span class="line">        <span class="keyword">return</span> [<span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">14</span>:</span><br><span class="line">        <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">15</span>:</span><br><span class="line">        <span class="keyword">return</span> [<span class="number">0</span>, <span class="number">3</span>]</span><br><span class="line">    <span class="keyword">return</span> [comb(n - <span class="number">4</span>)[<span class="number">0</span>] + <span class="number">1</span>, comb(n - <span class="number">4</span>)[<span class="number">1</span>]]</span><br></pre></td></tr></table></figure><p>题目还问了这个算法最多使用多少张5c的邮票，所有的base case中5c最多是3张，而我们只修改递归返回的4c邮票的数量，所以5c最多就是3张。</p><p>测试这个代码会发现这个代码等价于尽可能多的使用4c邮票的策略，如果我想尽可能多得使用5c邮票呢。简单改动几个地方即可，这对应数学归纳法使用k+1-5进行证明的版本。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">comb</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">12</span>:</span><br><span class="line">        <span class="keyword">return</span> [<span class="number">3</span>, <span class="number">0</span>]</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">13</span>:</span><br><span class="line">        <span class="keyword">return</span> [<span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">14</span>:</span><br><span class="line">        <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">15</span>:</span><br><span class="line">        <span class="keyword">return</span> [<span class="number">0</span>, <span class="number">3</span>]</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">16</span>:</span><br><span class="line">        <span class="keyword">return</span> [<span class="number">4</span>, <span class="number">0</span>]</span><br><span class="line">    <span class="keyword">return</span> [comb(n - <span class="number">5</span>)[<span class="number">0</span>], comb(n - <span class="number">5</span>)[<span class="number">1</span>] + <span class="number">1</span>]</span><br></pre></td></tr></table></figure><h3 id="Celebrity-Problem"><a href="#Celebrity-Problem" class="headerlink" title="Celebrity Problem"></a>Celebrity Problem</h3><p>名人问题</p><p>原题</p><p>A celebrity at a party is someone who everyone knows, yet who knows no one. Suppose that you are at a party with n people. For any pair of people A and B at the party, you can ask A if they know B and receive an honest answer. Give a recursive algorithm to determine whether there is a celebrity at the party, and if so who, by asking at most 3n−4 questions. (Note: for the purpose of this question you are just visiting the party to ask questions. What you are trying to determine is whether the n people actually attending the party include a celebrity.) Prove by induction that your algorithm always correctly identifies a celebrity if there is one, and that the number of questions is at most 3n−4.</p><p>一场派对中的名人满足以下条件</p><p>1.名人不认识任何其他人</p><p>2.其他人都认识名人</p><p>可以对一个人提问，提问一个人是否认识另外一个人，并且总能得到诚实的回答</p><p>要求设计递归算法，给定n个人，判定是否有名人存在，有则输出这个名人。并使用归纳法证明算法的正确性，同时证明算法至多需要提问3n-4次。</p><p>这个题刚看比较蒙，直接设计递归算法对我来说有点难，于是我根据3n-4这个线索先进行数学归纳（读者也可以思考一下，感觉对于初学者这题还是有难度的）</p><p><strong>基本情况</strong></p><p>n &#x3D; 2， 3n - 4 &#x3D;2</p><p>这里给相当于给了提示，为什么数字设置成3n-4，为什么2个人需要提2个问题。</p><p>对于A与B两个人，询问A是否知道B，如果A知道B，那么A一定不是名人，问题在于名人不是必然存在，所以即使知道A不是名人，还是要问B是否知道A。B知道A，那么两个人都不是名人，B不知道A，B就是名人。至此基本情况n &#x3D; 2满足条件，可以通过2个问题正确地获得答案。</p><p><strong>归纳假设</strong></p><p>假设对于k个人，可以使用最多3k-4个问题获取名人</p><p><strong>归纳递推</strong>（思考一下该怎么递推）</p><p>我们已经假设了k个人的情况成立，需要证明k+1的情况也成立。</p><p>最开始我考虑以下思路：</p><p>我们使用3k-4个问题找到了k个人中的一个可能名人，接下来需要对这个可能名人和多加的那个人重复n&#x3D;2的步骤就可以确认可能名人是不是名人。</p><p>这里存在两个问题，一个是使用3k-4个问题对于k个人的询问，最终可能获得的是这k个人中不存在名人，这种情况代表着对于多出来的那个人，还需要至多2k次提问来确认其是不是名人，因为如果多的人确实是名人，就需要通过k次提问，确保其满足条件1，另外k次提问确保满足条件2，这就不保证最多需要3k-4次了。</p><p>另一个问题是，如果找出了k个人中的可能名人，和多出的人重复n&#x3D;2的步骤，得到的结果有3种可能，1是可能名人确实是名人，2两个人都不是名人，这两种情况可以返回正确答案，但如果是第三种可能-多出的人是名人呢，又回到了第一个问题，只不过此时只需要2k-2次。</p><p>无论如何，以上思路都是不能保证正确性的，保证正确性则次数必然超出范围。</p><p>思考一下上面思路导致的两个问题，共性就是无论我对于k个人的询问结果如何，在最坏情况下，<strong>由于对于多出的那个人的身份无法确认</strong>，都需要去再次确认多出的那个人的身份，这必然导致提问次数超出。</p><p>怎么确认多出的那个人的身份，实际上我们不需要确认，我们可以把已经确认身份的人作为多出的那个人。</p><p>思路如下：</p><p>对于k+1个人，选择两个人AB，询问A是否知道B</p><p>若A知道B，A一定不是名人，将A排除在外，对于剩余k个人执行询问，考虑最坏情形，我们得到了一个可能名人C，对A与C执行n&#x3D;2，返回结果，此时一定是正确的</p><p>若A不知道B，B一定不是名人，上面的A改成B即可。</p><p>最多询问多少次呢，一开始的询问算1次，k个人的询问花费3k-4次，最后n&#x3D;2的情形花费2次，共</p><p>3k-4+1+2 &#x3D; 3(k+1)-4次，证明完成。</p><p>接下来根据归纳法给出递归算法，这里要说的是，在leetcode和一些其他题库中，名人问题中的认识关系使用矩阵表示，这里的算法使用python字典表示，这里的算法按刷题网站的输入格式和函数原型来写实际上不太好写（也可能是我太菜），不过自己造的一些测试样例也是可以验证正确性的。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">knows</span>(<span class="params">people, a, b</span>):</span><br><span class="line">    <span class="keyword">return</span> b <span class="keyword">in</span> people[a]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">people</span>):</span><br><span class="line">    names = <span class="built_in">list</span>(people.keys())</span><br><span class="line">    n = <span class="built_in">len</span>(names)</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">2</span>:</span><br><span class="line">        A, B = names</span><br><span class="line">        <span class="keyword">if</span> knows(people, A, B):</span><br><span class="line">            <span class="keyword">if</span> knows(people, B, A):</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;不存在&quot;</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> B</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> A</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        A, B = names[<span class="number">0</span>], names[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> knows(people, A, B):</span><br><span class="line">            A_people = people[A]</span><br><span class="line">            <span class="keyword">del</span> people[A]</span><br><span class="line">            celebrity = find(people)</span><br><span class="line">            <span class="keyword">if</span> celebrity != <span class="string">&quot;不存在&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> find(&#123;A : A_people, celebrity : people[celebrity]&#125;)</span><br><span class="line">            <span class="keyword">return</span> celebrity</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            B_people = people[B]</span><br><span class="line">            <span class="keyword">del</span> people[B]</span><br><span class="line">            celebrity = find(people)</span><br><span class="line">            <span class="keyword">if</span> celebrity != <span class="string">&quot;不存在&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> find(&#123;B : B_people, celebrity : people[celebrity]&#125;)</span><br><span class="line">            <span class="keyword">return</span> celebrity</span><br></pre></td></tr></table></figure><p>全知全能的bing ai给出了一些测试样例</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test_find</span>():</span><br><span class="line">    people = &#123;</span><br><span class="line">        <span class="string">&quot;Alice&quot;</span>: [<span class="string">&quot;Bob&quot;</span>],</span><br><span class="line">        <span class="string">&quot;Bob&quot;</span>: [],</span><br><span class="line">        <span class="string">&quot;Charlie&quot;</span>: [<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Bob&quot;</span>],</span><br><span class="line">        <span class="string">&quot;David&quot;</span>: [<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Charlie&quot;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">assert</span> find(people) == <span class="string">&quot;Bob&quot;</span></span><br><span class="line"></span><br><span class="line">    people = &#123;</span><br><span class="line">        <span class="string">&quot;Alice&quot;</span>: [<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Charlie&quot;</span>],</span><br><span class="line">        <span class="string">&quot;Bob&quot;</span>: [<span class="string">&quot;Charlie&quot;</span>],</span><br><span class="line">        <span class="string">&quot;Charlie&quot;</span>: []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">assert</span> find(people) == <span class="string">&quot;Charlie&quot;</span></span><br><span class="line"></span><br><span class="line">    people = &#123;</span><br><span class="line">        <span class="string">&quot;Alice&quot;</span>: [<span class="string">&quot;Bob&quot;</span>],</span><br><span class="line">        <span class="string">&quot;Bob&quot;</span>: [<span class="string">&quot;Alice&quot;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">assert</span> find(people) == <span class="string">&quot;不存在&quot;</span></span><br><span class="line"></span><br><span class="line">    people = &#123;</span><br><span class="line">        <span class="string">&quot;Alice&quot;</span>: [<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Charlie&quot;</span>, <span class="string">&quot;David&quot;</span>],</span><br><span class="line">        <span class="string">&quot;Bob&quot;</span>: [<span class="string">&quot;Charlie&quot;</span>, <span class="string">&quot;David&quot;</span>],</span><br><span class="line">        <span class="string">&quot;Charlie&quot;</span>: [<span class="string">&quot;David&quot;</span>],</span><br><span class="line">        <span class="string">&quot;David&quot;</span>: []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">assert</span> find(people) == <span class="string">&quot;David&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;所有测试用例都通过了！&quot;</span>)</span><br><span class="line"></span><br><span class="line">test_find()</span><br></pre></td></tr></table></figure><p>‍</p>]]></content>
      
      
      <categories>
          
          <category> 学习小记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CS课程 </tag>
            
            <tag> 学习记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS61A学习总结与个人经验分享</title>
      <link href="/posts/d8b71ed7.html"/>
      <url>/posts/d8b71ed7.html</url>
      
        <content type="html"><![CDATA[<p>第一篇博客，献给最好的CS入门课，CS61A。</p><p>自今年10月份起至今，历时2个月，半玩半学地将CS61A肝完了。2个月的时间有小半时间都在摸鱼，最近两周幡然悔悟，连夜加班，终于在17日3点堪堪拿下了最后一个项目，在此记录一些自己的心得。</p><h3 id="课程定位"><a href="#课程定位" class="headerlink" title="课程定位"></a>课程定位</h3><p>来学习这门课的，应该多少都对国外CS课程有总体的认识，如果没有，北大学长发起的<a href="https://csdiy.wiki/">CS自学指南</a>和浙大学长发起的<a href="https://conanhujinming.github.io/comments-for-awesome-courses/">名校课程公开评价网</a>都是很好的参考，其中包含这门课的介绍与课程资料。CS61A作为导论级的CS入门课，其难度实际上并不低。如果你是零基础，要做好在做课程作业时遭遇困难的准备，建议给自己一定的思考时间，但不要一直卡在某个地方。这门课完全符合其CS导论课的定位，其包含内容十分广阔，有的地方弄不明白不需要死磕到底，过段时间再看或许能有新的理解。</p><h3 id="学习建议"><a href="#学习建议" class="headerlink" title="学习建议"></a>学习建议</h3><p><strong>版本选择</strong>：本人选择的是<a href="https://inst.eecs.berkeley.edu/~cs61a/fa20/">20FALL</a>。由于我有一定的强迫症，在选择版本时纠结许久，在这里给出我选择课程版本的参考标准，也可以用于其他课程的版本选择。首先是视频，翻译版本优先，有的课在b站上没有翻译，就使用language reactor插件，可以翻译youtube上有字幕的视频，有能力的可以尝试无翻译版本，适应过来的话对于后面的学习更加有利。之后是有无答案参考，自学课程一个第二大的问题就是作业没有答案对照（第一大问题是缺乏自律性）。以上两个条件都满足，那么选择哪个版本应该不会有很大的区别，有的人（比如我）就是不知道这时候选哪个好，很简单，挑人多的。</p><p><strong>作业评测</strong>：如果运行官网教程的python3这样的指令没有反应，尝试把python3改成python。运行ok时，在最后添加–local参数，否则在评测后会要求你提供学校账号。有的问题询问你对应的输出，如果一直写不对（我被这个整破防过），可以在官网的解释器上输入对应的语句看看输出是什么。如果是在项目中，就先把代码编写好，再自己跑一下试试。</p><p><strong>资料选择</strong>：lab，hw，project必做，disc中包含一些知识的总结，如果没有时间做disc，建议看一看加深理解。官网reading的链接无法直接访问，在链接前面加上www.即可。readings内容比较丰富且都是英文，建议在看完lecture后再读。课程的reading是UCB教授对于SICP，计算机程序的构造与解释的改编，我没有读过，但这本书评价非常高，也被称为是这门课的灵魂，学有余力可以看一看。<a href="https://github.com/AzatAI/cs_books">这里</a>包含这本书的中英文pdf，同时还有许多其他电子书，实际上在谷歌直接搜索书名+pdf基本上都可以找到你需要的。</p><h3 id="学习感受"><a href="#学习感受" class="headerlink" title="学习感受"></a>学习感受</h3><p>作为一名高中无基础 and 大一浑浑噩噩 and 学习效率不高的普通学生(如果你看过很多其他博客，你会发现使得上述修饰语句为假的老哥比比皆是)，我在学习这门课之前始终对于CS课程提不起多大兴趣，大一学校教的C++实在是乏善可陈，更别提还有一众CS无关的课程牵扯我的精力(说的就是你，大物实验)，我在大一唯一一件拿得出手的成就，仅仅是学了一点点浅显的算法，混了个蓝桥杯省二。当然，在一众高中oier的碾压下，这也算不上什么成就。于是自从拿了省二后我便迷失了方向，直到看到了CS61A。</p><p>我觉得相比国内课程，国外课程比较突出的就是其作业，我觉得二者差距很难用言语形容，看到评测通过带来的痛快感，显然不是写几个.h.cpp文件交到邮箱之后便石沉大海的过程能比拟的。要问CS61A改变了我什么，它改变了我被动式学习CS课程的态度，我建议CS新生来学习这门课，不仅仅是学习知识，更多的是点燃对CS的热情，因为这门课涉及内容广泛，每个地方又恰好点到为止，吸引你去深入，南京大学已经引入了<a href="https://sicp.pascal-lab.net/2023/">这门课程</a>，身为隔壁的车专人实名羡慕。这里贴上UCB CS专业的课程路线以供参考。或许学完这门课你也会想继续学习其他课程。</p><p><img src="https://bu.dusays.com/2024/03/04/65e4a2fb30e40.png"></p><p>这门课的优秀不仅仅在其评分系统，作业本身的质量也十分高，lab&#x2F;hw的有些问题很有意思，有一道题我在写的过程中灵光一现，洋洋洒洒写下几百字的思考总结，如果你认真学习，我相信你也会有和我有一样的感受。而project或许不像你想象中那样从零开始构建一个庞大的代码工程，而是让你在一个接近完善的框架中补充逻辑，或许相对简陋，但是更有利于你专注于课程的内容本身。</p><h3 id="Don’t-compare"><a href="#Don’t-compare" class="headerlink" title="Don’t compare"></a>Don’t compare</h3><p>在最后的lecture的最后2分钟，Denero教授告诉了我们他母亲对他的一句advice，Don’t compare，这句话我希望每一个像我一样在CS学习路上迷茫的人都要去了解。实际上我现在依然处在与强者比较而自我怀疑的陷阱中，我也没有资格来给予我自己的建议。我想每一个普通人都会经历这样的过程，豪情满志到心灰意冷，无非是不想接受自己落后于别人，不想接受自己不如别人。大部分人总要接受这样的事实，像我这样玻璃心一点的，不愿接受，就去寻找自己能够领先于人的地方，找不到，就此迷失。但是“comparing yourselves to other people becomes meaningless rapidly as what really matter is what you could do yourself, like what you’re capable of and what you bother to do and how you choose to spend your time”。</p><p>我想说的是，CS作为一个高度开放，且热度极高的领域，不比其他专业，你很容易看到别人将你碾压得体无完肤，因此我想这句话，Don’t compare，对CS学生有特别的意义，我在此单独拿出来分享。</p><h3 id="轻松时刻"><a href="#轻松时刻" class="headerlink" title="轻松时刻"></a>轻松时刻</h3><p>学习CS61A的人的最爽时刻：<img src="https://bu.dusays.com/2024/03/04/65e4a315d18dd.png"></p><p>scheme画廊：</p><p>当时火爆的among us(居然已经3年了)</p><p><img src="https://bu.dusays.com/2024/03/04/65e4a3358192c.png"></p><p>查询UCB学生精神状态：<img src="https://bu.dusays.com/2024/03/04/65e4a358282c7.png"></p><p>两位可爱的教授：</p><p><img src="https://bu.dusays.com/2024/03/04/65e4a36ecd7b7.png"></p><p>完全一致</p><p><img src="https://bu.dusays.com/2024/03/04/65e4a37f51844.png"></p><h3 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h3><p><a href="https://www.bilibili.com/read/cv18152970/?spm_id_from=333.999.0.0">https://www.bilibili.com/read/cv18152970/?spm_id_from=333.999.0.0</a></p><p><a href="https://zhuanlan.zhihu.com/p/456110373">https://zhuanlan.zhihu.com/p/456110373</a></p><p><a href="https://github.com/half-dreamer/CS61A-20fa">https://github.com/half-dreamer/CS61A-20fa</a></p><p><a href="https://blog.liuly.moe/posts/cs61a">https://blog.liuly.moe/posts/cs61a</a></p>]]></content>
      
      
      <categories>
          
          <category> 经验分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CS课程 </tag>
            
            <tag> 心得体会 </tag>
            
            <tag> 学习记录 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
