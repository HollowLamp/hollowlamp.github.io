<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CS70学习记录-递归与数学归纳</title>
      <link href="/posts/12e4fd6e.html"/>
      <url>/posts/12e4fd6e.html</url>
      
        <content type="html"><![CDATA[<p>CS70 note3 主要讲的是数学归纳法，其中也谈到了数学归纳与递归函数的关系。以下是note 3中的两个问题，感觉还挺有意思。笔者此时还没学过正经的算法分析课，理解不到位的地方欢迎指正。</p><h3 id="Postage-Stamp-Problem"><a href="#Postage-Stamp-Problem" class="headerlink" title="Postage Stamp Problem"></a>Postage Stamp Problem</h3><p>原题</p><p>Use the proof of Theorem 3.6 to design an algorithm that, given any amount of postage of at least 12c, outputs the numbers of 4c and 5c stamps that make up this postage. What’s the largest number of 5c stamps your algorithm will ever use?</p><p><img src="https://cdn.jsdelivr.net/gh/HollowLamp/picbed@main/img/image-20231226134447134.png" alt="image-20231226134447134"></p><p>大意就是根据这个归纳法证明的思路，设计一个算法，输入一个n，输出对应x与y</p><p>这里归纳法的思路就是，给出4个base case，之后假设在一个范围内，对于每一个n都成立，这个范围称为假设成立范围，然后将范围扩大一个数，我们需要证明对于多加的k+1也成立。我们的假设成立范围是[12, k]，而要证明的k+1在[16, 无穷大]这个范围内。而k+1-4&#x3D;k-3处在[12, k]范围内，说明k+1-4可以被表示为4x+5y的形式，那么k+1就必然可以被表示为4(x + 1)+5y的形式，说明对于k+1也成立，证明完成。</p><p>显然这题作为一个程序设计题有很多写法，效率也各不相同，按题目的意思来做不一定是最高效的写法。</p><p>按这个证明的思路写递归还是很好写的，一步步翻译就好了</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">comb</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">12</span>:</span><br><span class="line">        <span class="keyword">return</span> [<span class="number">3</span>, <span class="number">0</span>]</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">13</span>:</span><br><span class="line">        <span class="keyword">return</span> [<span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">14</span>:</span><br><span class="line">        <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">15</span>:</span><br><span class="line">        <span class="keyword">return</span> [<span class="number">0</span>, <span class="number">3</span>]</span><br><span class="line">    <span class="keyword">return</span> [comb(n - <span class="number">4</span>)[<span class="number">0</span>] + <span class="number">1</span>, comb(n - <span class="number">4</span>)[<span class="number">1</span>]]</span><br></pre></td></tr></table></figure><p>题目还问了这个算法最多使用多少张5c的邮票，所有的base case中5c最多是3张，而我们只修改递归返回的4c邮票的数量，所以5c最多就是3张。</p><p>测试这个代码会发现这个代码等价于尽可能多的使用4c邮票的策略，如果我想尽可能多得使用5c邮票呢。简单改动几个地方即可，这对应数学归纳法使用k+1-5进行证明的版本。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">comb</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">12</span>:</span><br><span class="line">        <span class="keyword">return</span> [<span class="number">3</span>, <span class="number">0</span>]</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">13</span>:</span><br><span class="line">        <span class="keyword">return</span> [<span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">14</span>:</span><br><span class="line">        <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">15</span>:</span><br><span class="line">        <span class="keyword">return</span> [<span class="number">0</span>, <span class="number">3</span>]</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">16</span>:</span><br><span class="line">        <span class="keyword">return</span> [<span class="number">4</span>, <span class="number">0</span>]</span><br><span class="line">    <span class="keyword">return</span> [comb(n - <span class="number">5</span>)[<span class="number">0</span>], comb(n - <span class="number">5</span>)[<span class="number">1</span>] + <span class="number">1</span>]</span><br></pre></td></tr></table></figure><h3 id="Celebrity-Problem"><a href="#Celebrity-Problem" class="headerlink" title="Celebrity Problem"></a>Celebrity Problem</h3><p>名人问题</p><p>原题</p><p>A celebrity at a party is someone who everyone knows, yet who knows no one. Suppose that you are at a party with n people. For any pair of people A and B at the party, you can ask A if they know B and receive an honest answer. Give a recursive algorithm to determine whether there is a celebrity at the party, and if so who, by asking at most 3n−4 questions. (Note: for the purpose of this question you are just visiting the party to ask questions. What you are trying to determine is whether the n people actually attending the party include a celebrity.) Prove by induction that your algorithm always correctly identifies a celebrity if there is one, and that the number of questions is at most 3n−4.</p><p>一场派对中的名人满足以下条件</p><p>1.名人不认识任何其他人</p><p>2.其他人都认识名人</p><p>可以对一个人提问，提问一个人是否认识另外一个人，并且总能得到诚实的回答</p><p>要求设计递归算法，给定n个人，判定是否有名人存在，有则输出这个名人。并使用归纳法证明算法的正确性，同时证明算法至多需要提问3n-4次。</p><p>这个题刚看比较蒙，直接设计递归算法对我来说有点难，于是我根据3n-4这个线索先进行数学归纳（读者也可以思考一下，感觉对于初学者这题还是有难度的）</p><p><strong>基本情况</strong></p><p>n &#x3D; 2， 3n - 4 &#x3D;2</p><p>这里给相当于给了提示，为什么数字设置成3n-4，为什么2个人需要提2个问题。</p><p>对于A与B两个人，询问A是否知道B，如果A知道B，那么A一定不是名人，问题在于名人不是必然存在，所以即使知道A不是名人，还是要问B是否知道A。B知道A，那么两个人都不是名人，B不知道A，B就是名人。至此基本情况n &#x3D; 2满足条件，可以通过2个问题正确地获得答案。</p><p><strong>归纳假设</strong></p><p>假设对于k个人，可以使用最多3k-4个问题获取名人</p><p><strong>归纳递推</strong>（思考一下该怎么递推）</p><p>我们已经假设了k个人的情况成立，需要证明k+1的情况也成立。</p><p>最开始我考虑以下思路：</p><p>我们使用3k-4个问题找到了k个人中的一个可能名人，接下来需要对这个可能名人和多加的那个人重复n&#x3D;2的步骤就可以确认可能名人是不是名人。</p><p>这里存在两个问题，一个是使用3k-4个问题对于k个人的询问，最终可能获得的是这k个人中不存在名人，这种情况代表着对于多出来的那个人，还需要至多2k次提问来确认其是不是名人，因为如果多的人确实是名人，就需要通过k次提问，确保其满足条件1，另外k次提问确保满足条件2，这就不保证最多需要3k-4次了。</p><p>另一个问题是，如果找出了k个人中的可能名人，和多出的人重复n&#x3D;2的步骤，得到的结果有3种可能，1是可能名人确实是名人，2两个人都不是名人，这两种情况可以返回正确答案，但如果是第三种可能-多出的人是名人呢，又回到了第一个问题，只不过此时只需要2k-2次。</p><p>无论如何，以上思路都是不能保证正确性的，保证正确性则次数必然超出范围。</p><p>思考一下上面思路导致的两个问题，共性就是无论我对于k个人的询问结果如何，在最坏情况下，<strong>由于对于多出的那个人的身份无法确认</strong>，都需要去再次确认多出的那个人的身份，这必然导致提问次数超出。</p><p>怎么确认多出的那个人的身份，实际上我们不需要确认，我们可以把已经确认身份的人作为多出的那个人。</p><p>思路如下：</p><p>对于k+1个人，选择两个人AB，询问A是否知道B</p><p>若A知道B，A一定不是名人，将A排除在外，对于剩余k个人执行询问，考虑最坏情形，我们得到了一个可能名人C，对A与C执行n&#x3D;2，返回结果，此时一定是正确的</p><p>若A不知道B，B一定不是名人，上面的A改成B即可。</p><p>最多询问多少次呢，一开始的询问算1次，k个人的询问花费3k-4次，最后n&#x3D;2的情形花费2次，共</p><p>3k-4+1+2 &#x3D; 3(k+1)-4次，证明完成。</p><p>接下来根据归纳法给出递归算法，这里要说的是，在leetcode和一些其他题库中，名人问题中的认识关系使用矩阵表示，这里的算法使用python字典表示，这里的算法按刷题网站的输入格式和函数原型来写实际上不太好写（也可能是我太菜），不过自己造的一些测试样例也是可以验证正确性的。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">knows</span>(<span class="params">people, a, b</span>):</span><br><span class="line">    <span class="keyword">return</span> b <span class="keyword">in</span> people[a]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">people</span>):</span><br><span class="line">    names = <span class="built_in">list</span>(people.keys())</span><br><span class="line">    n = <span class="built_in">len</span>(names)</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">2</span>:</span><br><span class="line">        A, B = names</span><br><span class="line">        <span class="keyword">if</span> knows(people, A, B):</span><br><span class="line">            <span class="keyword">if</span> knows(people, B, A):</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;不存在&quot;</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> B</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> A</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        A, B = names[<span class="number">0</span>], names[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> knows(people, A, B):</span><br><span class="line">            A_people = people[A]</span><br><span class="line">            <span class="keyword">del</span> people[A]</span><br><span class="line">            celebrity = find(people)</span><br><span class="line">            <span class="keyword">if</span> celebrity != <span class="string">&quot;不存在&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> find(&#123;A : A_people, celebrity : people[celebrity]&#125;)</span><br><span class="line">            <span class="keyword">return</span> celebrity</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            B_people = people[B]</span><br><span class="line">            <span class="keyword">del</span> people[B]</span><br><span class="line">            celebrity = find(people)</span><br><span class="line">            <span class="keyword">if</span> celebrity != <span class="string">&quot;不存在&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> find(&#123;B : B_people, celebrity : people[celebrity]&#125;)</span><br><span class="line">            <span class="keyword">return</span> celebrity</span><br></pre></td></tr></table></figure><p>全知全能的bing ai给出了一些测试样例</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test_find</span>():</span><br><span class="line">    people = &#123;</span><br><span class="line">        <span class="string">&quot;Alice&quot;</span>: [<span class="string">&quot;Bob&quot;</span>],</span><br><span class="line">        <span class="string">&quot;Bob&quot;</span>: [],</span><br><span class="line">        <span class="string">&quot;Charlie&quot;</span>: [<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Bob&quot;</span>],</span><br><span class="line">        <span class="string">&quot;David&quot;</span>: [<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Charlie&quot;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">assert</span> find(people) == <span class="string">&quot;Bob&quot;</span></span><br><span class="line"></span><br><span class="line">    people = &#123;</span><br><span class="line">        <span class="string">&quot;Alice&quot;</span>: [<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Charlie&quot;</span>],</span><br><span class="line">        <span class="string">&quot;Bob&quot;</span>: [<span class="string">&quot;Charlie&quot;</span>],</span><br><span class="line">        <span class="string">&quot;Charlie&quot;</span>: []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">assert</span> find(people) == <span class="string">&quot;Charlie&quot;</span></span><br><span class="line"></span><br><span class="line">    people = &#123;</span><br><span class="line">        <span class="string">&quot;Alice&quot;</span>: [<span class="string">&quot;Bob&quot;</span>],</span><br><span class="line">        <span class="string">&quot;Bob&quot;</span>: [<span class="string">&quot;Alice&quot;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">assert</span> find(people) == <span class="string">&quot;不存在&quot;</span></span><br><span class="line"></span><br><span class="line">    people = &#123;</span><br><span class="line">        <span class="string">&quot;Alice&quot;</span>: [<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Charlie&quot;</span>, <span class="string">&quot;David&quot;</span>],</span><br><span class="line">        <span class="string">&quot;Bob&quot;</span>: [<span class="string">&quot;Charlie&quot;</span>, <span class="string">&quot;David&quot;</span>],</span><br><span class="line">        <span class="string">&quot;Charlie&quot;</span>: [<span class="string">&quot;David&quot;</span>],</span><br><span class="line">        <span class="string">&quot;David&quot;</span>: []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">assert</span> find(people) == <span class="string">&quot;David&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;所有测试用例都通过了！&quot;</span>)</span><br><span class="line"></span><br><span class="line">test_find()</span><br></pre></td></tr></table></figure><p>‍</p>]]></content>
      
      
      <categories>
          
          <category> 学习小结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CS课程 </tag>
            
            <tag> 学习记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>普通CS学生的大学一年半</title>
      <link href="/posts/ed9bfe8b.html"/>
      <url>/posts/ed9bfe8b.html</url>
      
        <content type="html"><![CDATA[<p>进入大学一年半以来，感觉心一直是飘着的，找不到一个锚点，随便什么事情就能打乱我的步调，糟蹋我的心情。我一直是一个优柔寡断的人，总是不敢一做到底，现在大二上临近结束，我觉得再怎么犹豫，此时也应该锁定一个目标了。</p><p>同时，我还想再对过去一年半做个回顾。记得高三时写过一篇作文，题为《生活是否要有仪式感》，我写的是不应该有，好吧，现在我觉得应该有了，以此文作为告别过去的仪式吧，但愿我能摆脱长期萎靡的状态。顺便也给看到这篇文章的CS新生们一些参考，我的经历没有别的大佬那样具有借鉴意义，不过应该还是有一些教训意义的。</p><h2 id="大一上：许多巧合"><a href="#大一上：许多巧合" class="headerlink" title="大一上：许多巧合"></a>大一上：许多巧合</h2><h3 id="感想"><a href="#感想" class="headerlink" title="感想"></a><strong>感想</strong></h3><h4 id="关于绩点"><a href="#关于绩点" class="headerlink" title="关于绩点"></a>关于绩点</h4><p>回过头来看，对我这样的懒人来说，起手很重要，大一上的表现直接决定了我现在的状态，这主要是针对绩点而言。绩点重不重要，我想说的是对于处于迷茫期的大一新生来说，很重要，它决定了当你脱离了初入大学时的迷茫期后，你眼前还有多少路子可走。即使有很多出路用不着绩点，但是有很多条路与绩点强相关也是事实。</p><p>其实很多人进入大学后，只要不是整日在玩，认真学习是很一件自然而然的事情，毕竟这时候除开学习课程之外也没有什么非娱乐项目可做。但是这些人中总有人绩点会掉队（比如我），原因总是各种各样，身体因素，老师因素，感情因素，总结起来，都是<strong>巧合</strong>。</p><p>对我而言，要不是2022年末那最后一波疫情潮，我也不至于提前回家，挂着网课玩游戏，导致回来的时候期末考一塌糊涂。这样说确实是在把自己的问题全部推给外部因素，不过我比较佛系，问题归结到自己身上，除了能让我更悔不当初之外也没什么作用了。</p><p>换个人来的面对我当时的境地的话，其实完全能把绩点追回来（说是绩点低，其实除开高数均在80+，也还好吧），不过我还是懒了，疫情在家的状态带到了学校，这样做结果也可想而知，说多了都是泪。</p><h4 id="关于社交"><a href="#关于社交" class="headerlink" title="关于社交"></a>关于社交</h4><p>社交就是个因人而异的事情了，对我来说这是个很大问题。不过我在社交上的缺陷通过加入学生组织弥补了一部分。</p><p>知乎经常见到有反对加入学生会的论调，我觉得对于正常学校来说进个学生会也没什么大问题。就作用而言，加入院系组织的实际作用是要比加入校级组织大的，一方面你能从组织内同系的学长学姐处讨教经验，另一方面你能认识除了你的舍友外的同级人（社牛当我没说），加入这种组织，就算有些社恐，也应该是能结交一些相对熟识的朋友的。</p><p>总而言之，我的社交确实少得可怜，不过够用就行，社交广点，没有交心朋友也是虚的，无非增加点交到知心朋友的机会而已。社交能力受性格因素影响，性格受什么影响就不好说了，我觉得是从小到大经历的无数个巧合造就的，比如我不想做一个社恐，但我还是成为了一个社恐，<strong>巧合</strong>罢了。:）</p><h4 id="关于CS"><a href="#关于CS" class="headerlink" title="关于CS"></a>关于CS</h4><p>这个时期，我对CS的认识停留在算法题，不得不说看到代码通过测试很爽，导致我如今写课程lab也很关心有没有提供测试功能。可能学习就是需要这种摆在台面上的正向反馈吧。</p><p>我们学校大一教的是C++，大一上教的和C语言差别也不太大，都是变量循环递归那一套，于是我认为CS也就这样。虽说我在学习算法题，也就写写排序高精度这些比课程内容多一点点的东西，更可笑的是我当时因此还自鸣得意，毕竟靠着做的一些算法题目的基础，在疫情结束后的考试中C++成了我考得最高的课程。</p><p>要说是什么让我走上了学习算法的道路呢，得感谢我那初入大学什么都想尝试的心态，在各大平台搜集信息，找到了算竞这条路线，然后就开始学习算法。（提醒后来者，算竞就结果而言，是高中有经历的大佬们玩的智力游戏，零基础想出成果还是有难度的，慎重考虑。）</p><h2 id="大一下：混沌期"><a href="#大一下：混沌期" class="headerlink" title="大一下：混沌期"></a>大一下：混沌期</h2><p>这个时期只能说是烂完了，除开蓝桥杯省二之外毫无建树，绩点没提上来，想做什么事情也是毫无头绪。这个混沌不仅仅是结果层面，还是过程层面，我现在去回忆这个时期我做了什么时，我发现记忆清晰程度还低于大一上。唯一印象深刻的是，我高数课天天玩手机。因此导致即使无疫情干扰，我的高数成绩还和大一上一样。</p><p>这已经断了我走保研的希望，其他课程成绩和我相差不大的人，高数成绩基本都比我高10分。更逆天的是，高数占学分是6分，许多课只占2分，而且高数分两个学期，我两个学期都是入土成绩。导致当时高数成绩成了我的心病，由此对于我在高数课上的表现感到痛苦，印象很深。对绩点的希望破灭，我大一下的暑假就彻底烂了。</p><p>现在来看这个暑假是最不该烂的，就算不弄绩点，趁着这个暑假去学习一下东西，怎么说也比毫无进展好。当然之所以这么说，还是因为现在的我感觉自己很缺时间。</p><h2 id="大二上：重生了，但是还没活过来"><a href="#大二上：重生了，但是还没活过来" class="headerlink" title="大二上：重生了，但是还没活过来"></a>大二上：重生了，但是还没活过来</h2><p>以下都是完全就业导向的暴论：</p><p>学术界来看，因为低绩点，基本是无缘了，于是我在烂了一个暑假后打算进军工业界，然后查了些资料，好悬没给我气晕过去，都快成赛博土木了，我是不是要去送外卖了。不过我在这方面反倒变得很执着，可能除了工业界我没出可去了吧（体制内始终是我的最末选择），另一面我在先前在学习CS的时候感觉到了自己对它是有学习的热情的，我喜欢学习CS，我觉得我兴趣在这，还是科班，总该比那些培训班的（无贬义）的强一点，不过这点确实也不好保证，于是我的学习目标不是学习培训班的课程，如果是学校培训班课程就和培训班也没区别了。不过学培训班的课也不是出不来突出人才，不过对于学习CS这种事情我很挑剔，说白了就是不太喜欢这种带点量产性质的课（没上过，都是印象流评价）。</p><p>那除了培训班还有啥呢，还有咱CS科班的课呢。可惜的是国内大部分学校的CS专业都不是面向就业的，也就是说就工业界而言，大部分国内CS专业的课程质量是比不过培训班的，更别提培养方案上还有一众不相干课程了。再加上某些巧合因素，比如某个老师极度抽象，偏偏他还是教CS核心课程的，他好像就是天生来消解你上课热情的一样（这就是我这学期遇到的一位老师）。这种情况再去上他的课，除了抬绩点也没啥用处，产生额外的负面影响也说不准，减少不必要的投入是最好的，及格万岁。</p><p>还能学点什么呢，这时候眼光就要扩展了，国内CS教学不行，就去看看国外吧。</p><p>或许你会质疑国外课程的质量，但我认为只要克服语言障碍，你就能体会到国外CS教学的实力。我四处搜集资源，如今已经学完了CS61A，具体可以参考我之前的文章。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我给大二上的副标题是“重生了，但是还没活过来”，原本想写自己在学习国外CS课程的过程中陷入反复自我怀疑的问题，写着写着却发现自己已经不需要再去考虑自我怀疑的问题了，问题的答案，在不断审视自己过去的过程中自然就有了。反正我去干别的也是这副自我怀疑的样子，不如就干我喜欢的事情，现在的我在感叹自己失去了保研的机会，或许另一个世界的我也在后悔自己读了研究生呢。</p><p>无论怎么样，过去的都过去了，吸收了教训后就不要为之再困扰，再有困扰，就归结给巧合吧。</p><p>重要的是知道自己想做什么，在此之前做什么错事都是预期之内的，而且并没有损失什么。</p><p>暂时不知道自己想做什么，就去做能让自己未来有更多选择的事情，这样几率大一些。</p><p>如果很不巧自己想做的事情现在做不了，那就总结一下自己的过去，把错过某个节点的责任甩给外界，你就可以安心地做自己现在可以做的事情了。（不负责任的方案，不过已经错过了，就尽可能最小化影响吧）</p><p>这是个很不成熟的回望与总结，不过事物皆有成长的过程，或许几年后我的文笔与文思能比现在好不少呢。希望看到这篇文章的人，也能甩开包袱去做，去学习，去成长。一同勉励。</p>]]></content>
      
      
      <categories>
          
          <category> 生活记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心得体会 </tag>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS61A学习总结与个人经验分享</title>
      <link href="/posts/d8b71ed7.html"/>
      <url>/posts/d8b71ed7.html</url>
      
        <content type="html"><![CDATA[<p>第一篇博客，献给最好的CS入门课，CS61A。</p><p>自今年10月份起至今，历时2个月，半玩半学地将CS61A肝完了。2个月的时间有小半时间都在摸鱼，最近两周幡然悔悟，连夜加班，终于在17日3点堪堪拿下了最后一个项目，在此记录一些自己的心得。</p><h3 id="课程定位"><a href="#课程定位" class="headerlink" title="课程定位"></a>课程定位</h3><p>来学习这门课的，应该多少都对国外CS课程有总体的认识，如果没有，北大学长发起的<a href="https://csdiy.wiki/">CS自学指南</a>和浙大学长发起的<a href="https://conanhujinming.github.io/comments-for-awesome-courses/">名校课程公开评价网</a>都是很好的参考，其中包含这门课的介绍与课程资料。CS61A作为导论级的CS入门课，其难度实际上并不低。如果你是零基础，要做好在做课程作业时遭遇困难的准备，建议给自己一定的思考时间，但不要一直卡在某个地方。这门课完全符合其CS导论课的定位，其包含内容十分广阔，有的地方弄不明白不需要死磕到底，过段时间再看或许能有新的理解。</p><h3 id="学习建议"><a href="#学习建议" class="headerlink" title="学习建议"></a>学习建议</h3><p><strong>版本选择</strong>：本人选择的是<a href="https://inst.eecs.berkeley.edu/~cs61a/fa20/">20FALL</a>。由于我有一定的强迫症，在选择版本时纠结许久，在这里给出我选择课程版本的参考标准，也可以用于其他课程的版本选择。首先是视频，翻译版本优先，有的课在b站上没有翻译，就使用language reactor插件，可以翻译youtube上有字幕的视频，有能力的可以尝试无翻译版本，适应过来的话对于后面的学习更加有利。之后是有无答案参考，自学课程一个第二大的问题就是作业没有答案对照（第一大问题是缺乏自律性）。以上两个条件都满足，那么选择哪个版本应该不会有很大的区别，有的人（比如我）就是不知道这时候选哪个好，很简单，挑人多的。</p><p><strong>作业评测</strong>：如果运行官网教程的python3这样的指令没有反应，尝试把python3改成python。运行ok时，在最后添加–local参数，否则在评测后会要求你提供学校账号。有的问题询问你对应的输出，如果一直写不对（我被这个整破防过），可以在官网的解释器上输入对应的语句看看输出是什么。如果是在项目中，就先把代码编写好，再自己跑一下试试。</p><p><strong>资料选择</strong>：lab，hw，project必做，disc中包含一些知识的总结，如果没有时间做disc，建议看一看加深理解。官网reading的链接无法直接访问，在链接前面加上www.即可。readings内容比较丰富且都是英文，建议在看完lecture后再读。课程的reading是UCB教授对于SICP，计算机程序的构造与解释的改编，我没有读过，但这本书评价非常高，也被称为是这门课的灵魂，学有余力可以看一看。<a href="https://github.com/AzatAI/cs_books">这里</a>包含这本书的中英文pdf，同时还有许多其他电子书，实际上在谷歌直接搜索书名+pdf基本上都可以找到你需要的。</p><h3 id="学习感受"><a href="#学习感受" class="headerlink" title="学习感受"></a>学习感受</h3><p>作为一名高中无基础 and 大一浑浑噩噩 and 学习效率不高的普通学生(如果你看过很多其他博客，你会发现使得上述修饰语句为假的老哥比比皆是)，我在学习这门课之前始终对于CS课程提不起多大兴趣，大一学校教的C++实在是乏善可陈，更别提还有一众CS无关的课程牵扯我的精力(说的就是你，大物实验)，我在大一唯一一件拿得出手的成就，仅仅是学了一点点浅显的算法，混了个蓝桥杯省二。当然，在一众高中oier的碾压下，这也算不上什么成就。于是自从拿了省二后我便迷失了方向，直到看到了CS61A。</p><p>我觉得相比国内课程，国外课程比较突出的就是其作业，我觉得二者差距很难用言语形容，看到评测通过带来的痛快感，显然不是写几个.h.cpp文件交到邮箱之后便石沉大海的过程能比拟的。要问CS61A改变了我什么，它改变了我被动式学习CS课程的态度，我建议CS新生来学习这门课，不仅仅是学习知识，更多的是点燃对CS的热情，因为这门课涉及内容广泛，每个地方又恰好点到为止，吸引你去深入，南京大学已经引入了<a href="https://sicp.pascal-lab.net/2023/">这门课程</a>，身为隔壁的车专人实名羡慕。这里贴上UCB CS专业的课程路线以供参考。或许学完这门课你也会想继续学习其他课程。</p><p><img src="https://bu.dusays.com/2024/03/04/65e4a2fb30e40.png" alt="image-20231217221841619"></p><p>这门课的优秀不仅仅在其评分系统，作业本身的质量也十分高，lab&#x2F;hw的有些问题很有意思，有一道题我在写的过程中灵光一现，洋洋洒洒写下几百字的思考总结，如果你认真学习，我相信你也会有和我有一样的感受。而project或许不像你想象中那样从零开始构建一个庞大的代码工程，而是让你在一个接近完善的框架中补充逻辑，或许相对简陋，但是更有利于你专注于课程的内容本身。</p><h3 id="Don’t-compare"><a href="#Don’t-compare" class="headerlink" title="Don’t compare"></a>Don’t compare</h3><p>在最后的lecture的最后2分钟，Denero教授告诉了我们他母亲对他的一句advice，Don’t compare，这句话我希望每一个像我一样在CS学习路上迷茫的人都要去了解。实际上我现在依然处在与强者比较而自我怀疑的陷阱中，我也没有资格来给予我自己的建议。我想每一个普通人都会经历这样的过程，豪情满志到心灰意冷，无非是不想接受自己落后于别人，不想接受自己不如别人。大部分人总要接受这样的事实，像我这样玻璃心一点的，不愿接受，就去寻找自己能够领先于人的地方，找不到，就此迷失。但是“comparing yourselves to other people becomes meaningless rapidly as what really matter is what you could do yourself, like what you’re capable of and what you bother to do and how you choose to spend your time”。</p><p>我想说的是，CS作为一个高度开放，且热度极高的领域，不比其他专业，你很容易看到别人将你碾压得体无完肤，因此我想这句话，Don’t compare，对CS学生有特别的意义，我在此单独拿出来分享。</p><h3 id="轻松时刻"><a href="#轻松时刻" class="headerlink" title="轻松时刻"></a>轻松时刻</h3><p>学习CS61A的人的最爽时刻：<img src="https://bu.dusays.com/2024/03/04/65e4a315d18dd.png" alt="image-20231217223304879"></p><p>scheme画廊：</p><p>当时火爆的among us(居然已经3年了)</p><p><img src="https://bu.dusays.com/2024/03/04/65e4a3358192c.png" alt="image-20231217231421569"></p><p>查询UCB学生精神状态：<img src="https://bu.dusays.com/2024/03/04/65e4a358282c7.png" alt="image-20231217231552915"></p><p>两位可爱的教授：</p><p><img src="https://bu.dusays.com/2024/03/04/65e4a36ecd7b7.png" alt="image-20231217231625773"></p><p>完全一致</p><p><img src="https://bu.dusays.com/2024/03/04/65e4a37f51844.png" alt="image-20231217231733913"></p><h3 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h3><p><a href="https://www.bilibili.com/read/cv18152970/?spm_id_from=333.999.0.0">https://www.bilibili.com/read/cv18152970/?spm_id_from=333.999.0.0</a></p><p><a href="https://zhuanlan.zhihu.com/p/456110373">https://zhuanlan.zhihu.com/p/456110373</a></p><p><a href="https://github.com/half-dreamer/CS61A-20fa">https://github.com/half-dreamer/CS61A-20fa</a></p><p><a href="https://blog.liuly.moe/posts/cs61a">https://blog.liuly.moe/posts/cs61a</a></p>]]></content>
      
      
      <categories>
          
          <category> 经验分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CS课程 </tag>
            
            <tag> 学习记录 </tag>
            
            <tag> 心得体会 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
